# Runtime Smoke Tests для Deep Dive

## Шаг 1: Понять, что такое "JSON" и где он

**Важно:** Приложение само не создаёт JSON-файл.

"JSON" — это кусок текста, который печатается в **консоль** (Metro bundler / Logcat) с префиксом:

```
[DEEP_SMOKE_SESSION] { ... }
```

И отдельно (если есть):

```
[DEEP_SMOKE_L4] { ... }
```

**Где найти:**
- Metro bundler консоль (если используете Expo/React Native)
- Logcat (если используете Android)
- Xcode console (если используете iOS)

**Как скопировать:**
- Найдите блок, начинающийся с `[DEEP_SMOKE_SESSION]`
- Скопируйте весь JSON (от `{` до `}`)

---

## Шаг 2: Пробный прогон (обязательная проверка)

**Сделайте 1 Deep-сессию** и проверьте в `[DEEP_SMOKE_SESSION]`:

### Проверка №1 (критическая):

В `output.finalEvidenceTagsSample` должны появиться **хотя бы 1–2 тега, начинающихся на `sig.`**

**Пример правильного вывода:**
```json
"finalEvidenceTagsSample": [
  "l1_mood_neg",
  "sig.valence.neg",  // ← это должно быть!
  "l1_control_high",
  "sig.agency.high",  // ← и это!
  ...
]
```

**Если `sig.*` теги есть:**
✅ Отлично! Идём дальше по 10 сценариям.

**Если `sig.*` тегов нет:**
❌ Runtime smoke тесты сейчас бессмысленны (micro/gates не будут работать).
→ Сначала нужно исправить канонизацию тегов (см. `AK3-DEEP-TAGS-CANON-FIX`).

**Также проверьте:**
- `output.hasSigTags` должно быть `true`
- Если `hasSigTags: false` и есть теги → появится предупреждение `[DEEP_SMOKE_TAGS] WARNING`

---

## Шаг 3: Пройти 10 сценариев

**Сценарии (из `RUNTIME_SMOKE_DEEP.md`):**

### Группа A: Overloaded/Exhausted (4 сессии)
- **A1:** Overloaded — "слишком много задач" (конкретные ответы, мало NS)
- **A2:** Overloaded — "много стимулов/хаос" (1 конфликтный шаг)
- **A3:** Exhausted — "низкая энергия, без напряжения" (чистые ответы)
- **A4:** Exhausted vs Overloaded конфликт — "устал + напряжён + срочно" (2 конфликтных шага)

### Группа B: Connected/Detached (3 сессии)
- **B1:** Connected — "поддержка, контакт, энергия норм" (чистые)
- **B2:** Detached — "отстранённость, как будто не со мной" (чистые)
- **B3:** Social conflict — "контакт есть, но неприятно" (конфликтные)

### Группа C: Размытые/Not sure (3 сессии)
- **C1:** Размытое состояние — много NS (минимум 3 NS)
- **C2:** Смешанное — "чуть вниз, но и немного контроля" (2 NS + 1 конфликт)
- **C3:** Высокая неопределённость — "почти все NS"

**Процедура для каждой сессии:**
1. Запустите приложение и дойдите до Deep Dive
2. Выберите baseline согласно сценарию
3. Пройдите L1, отвечая как задано в сценарии
4. После завершения найдите в консоли блок `[DEEP_SMOKE_SESSION]`
5. Скопируйте весь JSON-блок
6. Сохраните в текстовый файл (временно)

---

## Шаг 4: Собрать NDJSON файл

**Создайте файл:**
```
client/scripts/out/deep_smoke_sessions.jsonl
```

**Формат:** Одна строка = один JSON (без лишних слов, без переносов строк внутри JSON)

**Пример:**
```jsonl
{"startedAt":1768744317465,"baseline":{"valence":3,"energy":2,"tension":8,"clarity":4,"control":3,"social":5},"macroBase":"overloaded","steps":[...],"output":{...},"endedBy":"early_exit"}
{"startedAt":1768744318000,"baseline":{"valence":2,"energy":1,"tension":3,"clarity":5,"control":4,"social":6},"macroBase":"exhausted","steps":[...],"output":{...},"endedBy":"normal"}
```

**Важно:**
- Каждый JSON должен быть на отдельной строке
- Не добавляйте комментарии или префиксы типа `[DEEP_SMOKE_SESSION]`
- Убедитесь, что JSON валидный (можно проверить через `JSON.parse`)

---

## Шаг 5: Запустить скрипт заполнения отчёта

**Команда:**
```bash
node scripts/fillRuntimeSmokeTests.js --input scripts/out/deep_smoke_sessions.jsonl --output RUNTIME_SMOKE_DEEP_FILLED.md
```

**Что делает скрипт:**
- Читает NDJSON файл
- Парсит каждую сессию
- Генерирует markdown секции для каждого сценария (A1–C3)
- Заполняет автоматически извлекаемые поля (baseline, steps, output, endedBy)

**Результат:**
- Создаётся/обновляется `RUNTIME_SMOKE_DEEP_FILLED.md`
- Автоматически заполнены: baseline, L1 responses, deep dive output
- Остаются пустыми для ручного заполнения: "Ожидание", "Оценка", "Почему"

---

## Шаг 6: Заполнить руками 3 поля на сценарий

В `RUNTIME_SMOKE_DEEP_FILLED.md` для каждого сценария допишите:

1. **"Ожидание до прохождения":**
   - Что вы ожидали получить (например: "overloaded.rushed" или "exhausted.drained")

2. **"Оценка: попали / частично / мимо":**
   - `попали` — результат точно соответствует ожиданию
   - `частично` — результат близок, но не идеален
   - `мимо` — результат не соответствует ожиданию

3. **"Почему" (1 строка):**
   - Краткое объяснение оценки (например: "Правильно определили overloaded, но выбрали cognitive вместо too_many_tasks")

---

## Troubleshooting

### Проблема: `sig.*` теги не появляются

**Симптомы:**
- В `finalEvidenceTagsSample` только `l1_*` теги
- `hasSigTags: false` в output
- Предупреждение `[DEEP_SMOKE_TAGS] WARNING` в консоли

**Возможные причины:**
1. `canonicalizeTags` не вызывается для L1 тегов
2. Маппинг `l1_*` → `sig.*` не работает
3. Теги не проходят через `pushAccepted`

**Что проверить:**
- Убедитесь, что в `DiagnosticFlowScreen.js` используется `canonicalizeTags(tags || [])`
- Проверьте, что `deriveSigTags()` правильно маппит теги
- Проверьте консоль на ошибки канонизации

### Проблема: JSON невалидный

**Симптомы:**
- Скрипт `fillRuntimeSmokeTests.js` выдаёт ошибку парсинга
- JSON содержит переносы строк внутри

**Решение:**
- Убедитесь, что каждый JSON на отдельной строке
- Удалите префиксы типа `[DEEP_SMOKE_SESSION]` из файла
- Проверьте валидность через `JSON.parse()` в Node.js

### Проблема: Сессия не логируется

**Симптомы:**
- В консоли нет `[DEEP_SMOKE_SESSION]`

**Что проверить:**
- Убедитесь, что `isDeep === true`
- Проверьте, что сессия завершилась (не зависла)
- Проверьте консоль на ошибки JavaScript

---

## Как получить endedBy=no_card (для тестирования)

**Процедура для воспроизведения no_card:**

1. Запустите Deep Dive сессию
2. На **каждом** L1 вопросе выбирайте **"Not sure" (NS)**
3. Продолжайте до тех пор, пока не пройдёте все доступные L1 карточки (обычно 10)
4. После последнего L1 карточки сессия завершится с `endedBy: "no_card"` (или `"max_steps"`, если достигнут лимит)

**Что проверить в JSON:**

- `steps.length` — должно быть близко к количеству L1 карточек (10)
- `finalEvidenceTagsCount` — должно быть 0 или очень мало (если NS не добавляет теги)
- `output.microSource` — должен быть `"fallback_sanity"` или `"fallback"`
- `output.needsRefine` — должен быть `true`
- `endedBy` — должен быть `"no_card"` или `"max_steps"`

**Примечание:** После исправления `AK3-DEEP-NO_CARD-FALLBACK_SKIPPED` (emergency fallback из skipped-карточек), `no_card` может стать реже, так как система будет использовать пропущенные из-за baseline redundancy карточки как последний резерв.

---

## Мини-backlog

### P0 — Проверка тегов (AK3-DEEP-TAGS-SMOKE-ASSERT)
✅ **Выполнено:** Добавлена проверка `hasSigTags` в `DiagnosticFlowScreen.js`
- Логируется предупреждение, если `sig.*` тегов нет
- `needsRefine` устанавливается в `true`, если тегов нет

### P0 — Канонизация тегов (AK3-DEEP-TAGS-CANON-FIX)
✅ **Выполнено:** Расширен `canonicalizeTags.js`
- Добавлен маппинг `l1_*` → `sig.*` через `deriveSigTags()`
- Теги автоматически преобразуются при канонизации

### P1 — Runtime smoke tests (AK3-POST-4c.2)
⏳ **В процессе:** Собрать 10 сессий → сгенерировать отчёт → заполнить оценки

---

## Следующие шаги

После успешного прохождения 10 сценариев:
1. Проанализировать результаты в `RUNTIME_SMOKE_DEEP_FILLED.md`
2. Выявить системные проблемы (если есть)
3. Исправить критические баги
4. Повторить smoke tests для проверки исправлений
