// src/domain/deepSession/types.js
// Task A3.0: Type contracts and documentation for deep session runner
// Comments in English only.

/**
 * Flow configuration for deep session
 * @typedef {Object} FlowConfig
 * @property {number} maxL1 - Maximum L1 cards to ask
 * @property {number} maxL2 - Maximum L2 cards to ask
 * @property {number} minL1 - Minimum L1 cards before early stop
 * @property {number} minL2 - Minimum L2 cards before early stop
 * @property {boolean} stopOnGates - Whether to allow early stop when gates are closed
 * @property {number} notSureRate - Probability of "not sure" response (0-1)
 * @property {string} profile - User profile ('decisive', 'uncertain', 'somatic', 'cognitive', 'mix', 'smoke-calibrated')
 * @property {boolean} coverageFirstEnabled - Whether to use coverage-first strategy for first N L1 picks
 * @property {boolean} baselineInjectionEnabled - Whether to inject baseline tags into evidence
 */

/**
 * Baseline metrics (6 dimensions)
 * @typedef {Object} BaselineMetrics
 * @property {number} valence - Valence dimension (1-9)
 * @property {number} energy - Energy dimension (1-9)
 * @property {number} tension - Tension dimension (1-9)
 * @property {number} clarity - Clarity dimension (1-9)
 * @property {number} control - Control dimension (1-9)
 * @property {number} social - Social dimension (1-9)
 */

/**
 * Session state (mutable during session)
 * @typedef {Object} SessionState
 * @property {number} step - Current step number (0-based)
 * @property {Set<string>} askedL1Ids - Set of asked L1 card IDs
 * @property {Set<string>} askedL2Ids - Set of asked L2 card IDs
 * @property {string[]} baselineEvidenceTags - Evidence tags from baseline injection
 * @property {string[]} cardEvidenceTags - Evidence tags from cards only
 * @property {string[]} evidenceTags - All evidence tags (baseline + cards)
 * @property {Object<string, boolean>} gatesHitAny - Gates hit by any source (baseline + cards)
 * @property {Object<string, boolean>} gatesHitCardsOnly - Gates hit by cards only
 * @property {string} macroBeforeCards - Macro state before any cards
 * @property {string|null} macroAfterL1 - Macro state after L1 phase
 * @property {string|null} macroAfterL2 - Macro state after L2 phase
 * @property {string|null} endedBy - How session ended ('l1', 'l2', 'early_stop', null)
 * @property {string|null} endedReason - Reason for ending ('max_l1', 'max_l2', 'gates_closed', 'no_l2_candidates', 'l2_plan_completed', null)
 * @property {string|null} microSource - Source of micro selection ('evidence', 'axis_only', 'fallback')
 * @property {string|null} microReason - Reason for micro selection ('specific', 'axis_only', 'no_evidence', 'no_matches_zero_score', 'zero_score_pick')
 * @property {Object|null} microTopCandidate - Top micro candidate (if available)
 * @property {Object<string, number>} gateFirstHitStep - Step when each gate was first hit
 * @property {Object<string, Object<string, number>>} gateHitCardIds - Card IDs that hit each gate
 * @property {Object|null} signalQuality - Signal quality fields (GS-MEANING-16): expectedMacro, signalScore, scoringTagCount, axisTagCount, eligibleForContradiction, topSignals, hasContradiction
 * @property {Array<Object>} coverageFirstPicks - First N L1 picks (for coverage-first tracking)
 * @property {string[]} signals - Uncertainty signals collected
 * @property {Object} gateState - Current gate state (legacy compatibility)
 */

/**
 * Session event (events-first architecture)
 * @typedef {Object} SessionEvent
 * @property {string} type - Event type
 * @property {number} [ts] - Timestamp (optional)
 * @property {number} step - Step number when event occurred
 * @property {string} [layer] - Layer ('L1', 'L2', 'BASELINE')
 * @property {string} [cardId] - Card ID (if applicable)
 * @property {Object} payload - Event-specific payload
 */

/**
 * Card choice/answer
 * @typedef {Object} CardChoice
 * @property {string} cardId - Card ID
 * @property {string} choice - Choice ('A', 'B', 'NS')
 * @property {string} [label] - Selected label (optional)
 * @property {string[]} [tags] - Selected tags (optional, will be canonicalized)
 */

/**
 * Next card result
 * @typedef {Object} NextCardResult
 * @property {string} layer - Layer ('L1' or 'L2')
 * @property {Object} card - Card object
 * @property {string} reason - Reason for selection
 */

/**
 * Commit answer result
 * @typedef {Object} CommitAnswerResult
 * @property {SessionEvent[]} events - Events generated by this action
 * @property {SessionState} state - Updated session state
 * @property {NextCardResult|null} nextCard - Next card to ask (or null if ended)
 * @property {boolean} ended - Whether session has ended
 */

/**
 * Runner dependencies (injected)
 * Task A3.1.0: Clarified interface contracts
 * @typedef {Object} RunnerDeps
 * @property {Function} rng - Seeded random number generator (returns 0-1)
 * @property {FlowConfig} flowConfig - Flow configuration
 * @property {Object} decks - Card decks { L1: Card[], L2: Card[] }
 * @property {Object} decksById - Card decks by ID { L1: Object<string, Card>, L2: Object<string, Card> }
 * @property {Function} l1Selector - Function to select next L1 card: (ctx) => { cardId: string, reason: string } | null
 * @property {Function} l2Planner - Function to build L2 probe plan: (ctx) => { plan: string[], reason?: string }
 * @property {Function} answerTagger - Function to extract tags from answer: ({ card, choice }) => string[]
 * @property {Object} macroEngine - Macro computation engine: { computeMacro: (ctx) => { macro: string, meta?: Object } }
 * @property {Object} microEngine - Micro selection engine: { selectMicro: (ctx) => { micro: Object|null, microSource: string, microReason: string, microTopCandidate: Object|null } }
 * @property {Object} tagPipeline - Tag pipeline functions: { canonicalizeTags, deriveSigTagsFromArray, buildScoringTags }
 * @property {Object} gateEngine - Gate evaluation functions: { hasGateMatch, GATE_ALLOW_LISTS }
 */

/**
 * Event types (enum-like constants)
 */
export const EVENT_TYPES = {
  SESSION_START: 'session_start',
  BASELINE_INJECTED: 'baseline_injected',
  CARD_SHOWN: 'card_shown',
  ANSWER_COMMITTED: 'answer_committed',
  EVIDENCE_ADDED: 'evidence_added',
  GATE_HIT: 'gate_hit',
  MACRO_UPDATED: 'macro_updated',
  MICRO_SELECTED: 'micro_selected',
  EXPECTED_MACRO_COMPUTED: 'expected_macro_computed', // GS-MEANING-16: Signal quality computation event
  SESSION_END: 'session_end',
};

/**
 * Layer constants
 */
export const LAYERS = {
  BASELINE: 'BASELINE',
  L1: 'L1',
  L2: 'L2',
};

/**
 * Ended reasons (normalized)
 * Task A3.2.1: Unified canonical list for all reports
 */
export const ENDED_REASONS = {
  MAX_L1: 'max_l1',
  MAX_L2: 'max_l2',
  MAX_STEPS_REACHED: 'max_steps_reached', // Alias for max_l2
  GATES_CLOSED: 'gates_closed',
  GATES_MET: 'gates_met', // Alias for gates_closed (for backward compatibility)
  NO_L2_CANDIDATES: 'no_l2_candidates',
  L2_PLAN_COMPLETED: 'l2_plan_completed',
  PLAN_COMPLETED: 'plan_completed', // Alias for l2_plan_completed
  EARLY_STOP: 'early_stop',
};

/**
 * Normalize ended reason to canonical form
 * Task A3.2.1: Map legacy reasons to canonical
 */
export function normalizeEndedReason(reason) {
  if (!reason) return null;
  
  const mapping = {
    'gates_met': ENDED_REASONS.GATES_CLOSED,
    'max_steps_reached': ENDED_REASONS.MAX_L2,
    'plan_completed': ENDED_REASONS.L2_PLAN_COMPLETED,
  };
  
  return mapping[reason] || reason;
}
